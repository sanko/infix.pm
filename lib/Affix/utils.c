/**
 * @file utils.c
 * @brief General-purpose utility and helper functions for the Affix module.
 *
 * @details This file contains various helper functions that are not directly
 * part of the FFI call mechanism but are used by other parts of the XSUB
 * implementation. This includes:
 *
 * - Functions for interacting with Perl's package system, such as creating
 *   constants, exporting functions to EXPORT_TAGS, and setting up @ISA inheritance.
 * - Powerful debugging helpers like `DumpHex` for inspecting raw memory and `DD`
 *   for pretty-printing Perl SVs using Data::Printer.
 *
 * This file is backend-agnostic and does not contain any 'infix' or FFI-specific logic.
 */

#include "../Affix.h"

// --- Perl Package Utilities ---

/**
 * @brief Creates a new constant in a given Perl package.
 * @details This is a wrapper around Perl's `newCONSTSUB` API.
 * @param package The name of the package (e.g., "Affix::Platform").
 * @param name The name of the constant to create.
 * @param value The SV* that the constant will hold.
 */
void register_constant(const char * package, const char * name, SV * value) {
    dTHX;
    HV * stash = gv_stashpv(package, GV_ADD);
    newCONSTSUB(stash, (char *)name, value);
}

/**
 * @brief (Internal) Adds a function name to an export tag in %EXPORT_TAGS.
 * @details This is the workhorse behind the `export_function` macro. It finds or
 *          creates the specified tag array within a package's %EXPORT_TAGS hash
 *          and pushes the function name onto it.
 * @param _export A pointer to the package's %EXPORT_TAGS HV.
 * @param what The name of the function to export.
 * @param _tag The name of the tag to add it to (e.g., ":core", ":types").
 */
void _export_function(pTHX_ HV * _export, const char * what, const char * _tag) {
    SV ** tag = hv_fetch(_export, _tag, strlen(_tag), TRUE);
    if (tag && SvOK(*tag) && SvROK(*tag) && (SvTYPE(SvRV(*tag))) == SVt_PVAV) {
        av_push((AV *)SvRV(*tag), newSVpv(what, 0));
    }
    else {
        AV * av = newAV();
        av_push(av, newSVpv(what, 0));
        (void)hv_store(_export, _tag, strlen(_tag), newRV_noinc(MUTABLE_SV(av)), 0);
    }
}

/**
 * @brief A convenience wrapper to create a numeric constant and export it.
 * @param package The target package.
 * @param name The name of the constant.
 * @param _tag The export tag to add it to.
 * @param val The double value for the constant.
 */
void export_constant(const char * package, const char * name, const char * _tag, double val) {
    dTHX;
    register_constant(package, name, newSVnv(val));
    // Assumes an `export_function` macro exists in a header.
    // We will use the direct call for clarity.
    _export_function(aTHX_ get_hv(form("%s::EXPORT_TAGS", package), GV_ADD), name, _tag);
}

/**
 * @brief Sets up inheritance for a Perl class.
 * @details Pushes the parent class name onto the child's @ISA array.
 * @param klass The name of the child class.
 * @param parent The name of the parent class.
 */
void set_isa(const char * package, const char * parent) {
    dTHX;
    // Ensure the parent package's stash exists
    gv_stashpv(parent, GV_ADD | GV_ADDMULTI);
    // Push parent onto @ISA
    av_push(get_av(form("%s::ISA", package), TRUE), newSVpv(parent, 0));
}


// --- Debugging Utilities ---

/**
 * @brief Prints a detailed, formatted hexadecimal and ASCII dump of a memory region.
 * @details This is an invaluable tool for debugging raw memory, such as C structs or
 *          the machine code generated by the JIT compiler. The output is printed to
 *          stdout.
 * @param addr A pointer to the start of the memory to dump.
 * @param len The number of bytes to dump.
 * @param file The source file where the dump was requested (for context).
 * @param line The line number where the dump was requested.
 */
void _DumpHex(pTHX_ const void * addr, size_t len, const char * file, int line) {
    if (addr == NULL) {
        warn("Dumping %" PRIuPTR " bytes from null pointer at %s line %d", len, file, line);
        return;
    }

    warn("Dumping %" PRIuPTR " bytes from %p at %s line %d", len, addr, file, line);
    if (len == 0) {
        warn("ZERO LENGTH");
        return;
    }

    const int perLine = 16;
    char ascii_buf[perLine + 1];
    const unsigned char * pc = (const unsigned char *)addr;

    for (size_t i = 0; i < len; i++) {
        // Print offset at the start of a new line
        if ((i % perLine) == 0) {
            if (i != 0) {
                printf("  |%s|\n", ascii_buf);  // Print ASCII from previous line
            }
            printf("  %04zx ", i);
        }

        // Print the hex code
        printf(" %02x", pc[i]);

        // Buffer the printable character
        if (pc[i] >= 0x20 && pc[i] <= 0x7e) {
            ascii_buf[i % perLine] = pc[i];
        }
        else {
            ascii_buf[i % perLine] = '.';
        }
        ascii_buf[(i % perLine) + 1] = '\0';
    }

    // Pad the last line and print its ASCII representation
    while ((len % perLine) != 0) {
        printf("   ");
        len++;
    }
    printf("  |%s|\n", ascii_buf);
    fflush(stdout);
}

/**
 * @brief Pretty-prints a Perl SV* for debugging using Data::Printer.
 * @details This is a very convenient wrapper that allows dumping complex Perl
 *          data structures from C code. It dynamically loads `Data::Printer` and
 *          calls its `p()` function.
 * @note This function has a runtime dependency on the `Data::Printer` Perl module.
 *       If it's not installed, this function will silently do nothing.
 * @param scalar The SV* to dump.
 * @param file The source file where the dump was requested.
 * @param line The line number where the dump was requested.
 */
void _DD(pTHX_ SV * scalar, const char * file, int line) {
    // Attempt to load Data::Printer if not already loaded.
    // PERL_LOADMOD_NOIMPORT prevents it from polluting the current namespace.
    (void)Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, newSVpvs("Data::Printer"), NULL, NULL);

    // Check if the function `Data::Printer::p` is available.
    if (!get_cvs("Data::Printer::p", GV_NOADD_NOINIT)) {
        warn("Data::Printer is not installed. Cannot dump variable at %s line %d.", file, line);
        sv_dump(scalar);  // Fallback to core sv_dump
        return;
    }

    dSP;
    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    XPUSHs(scalar);
    PUTBACK;

    // Call `Data::Printer::p` in scalar context. It returns the formatted string.
    int count = call_pv("Data::Printer::p", G_SCALAR);

    SPAGAIN;

    if (count == 1) {
        // Use warn to print the string, which includes file/line info.
        warn("DUMP at %s line %d:\n%s", file, line, SvPV_nolen(POPs));
    }
    else {
        warn("Call to Data::Printer::p failed at %s line %d.", file, line);
    }

    PUTBACK;
    FREETMPS;
    LEAVE;
}
