/**
 * @file marshal.c
 * @brief Implements data marshalling between Perl SVs and C types.
 *
 * @details This file contains the centralized logic for converting data back
 * and forth between Perl's dynamic `SV` representation and the static,
 * raw memory layout of C.
 *
 * It uses the `infix_type` descriptors generated by the `infix` library as a
 * blueprint to perform these conversions correctly, handling everything from
 * simple primitives to complex, nested structs and on-the-fly callback generation.
 */

#include "../Affix.h"
#include <string.h>  // For strlen and memcpy

// This global (defined in Affix.c) points to the currently executing forward
// trampoline's context. It's how we register on-the-fly callbacks for cleanup.
extern Affix_Context * current_call_context;


// Forward declaration for recursive marshalling
void marshal_sv_to_c(pTHX_ void * dest_c, SV * src_sv, const infix_type * type_info);
SV * ptr2sv(pTHX_ void * src_c, const infix_type * type_info);

/**
 * @brief Marshals (converts and writes) a Perl SV to a C memory location.
 * @param dest_c A pointer to the C memory to write to.
 * @param src_sv The source Perl SV containing the data.
 * @param type_info The infix infix_type that describes the C memory layout.
 */
void marshal_sv_to_c(pTHX_ void * dest_c, SV * src_sv, const infix_type * type_info) {
    if (!dest_c || !type_info)
        return;

    if (!SvOK(src_sv)) {
        // Handle undef: zero out the C memory.
        memset(dest_c, 0, type_info->size);
        return;
    }

    switch (type_info->category) {
    case INFIX_TYPE_PRIMITIVE:
        {
            switch (type_info->meta.primitive_id) {
            case INFIX_PRIMITIVE_BOOL:        { bool val = SvTRUE(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_SINT8:       { int8_t val = SvIV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_UINT8:       { uint8_t val = SvUV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_SINT16:      { int16_t val = SvIV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_UINT16:      { uint16_t val = SvUV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_SINT32:      { int32_t val = SvIV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_UINT32:      { uint32_t val = SvUV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_SINT64:      { int64_t val = SvIV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_UINT64:      { uint64_t val = SvUV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_FLOAT:       { float val = SvNV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_DOUBLE:      { double val = SvNV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
            case INFIX_PRIMITIVE_LONG_DOUBLE: { long double val = SvNV(src_sv); memcpy(dest_c, &val, sizeof(val)); break; }
#if !defined(INFIX_COMPILER_MSVC)
            case INFIX_PRIMITIVE_SINT128:
            case INFIX_PRIMITIVE_UINT128:
                {
                    __int128 val = SvIV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
#endif
            }
            break;
        }
    case INFIX_TYPE_POINTER:
        {
            const infix_type* pointee = type_info->meta.pointer_info.pointee_type;

            if (SvROK(src_sv) && SvTYPE(SvRV(src_sv)) == SVt_PVCV &&
                pointee && pointee->category == INFIX_TYPE_REVERSE_TRAMPOLINE)
            {
                // Delegate to the REVERSE_TRAMPOLINE handler.
                // NOTE: We pass the *pointee* type, which contains the actual signature.
                marshal_sv_to_c(aTHX_ dest_c, src_sv, pointee);
                return;
            } else {
                // It's a regular data pointer.
                void * ptr = sv_to_voidp(aTHX_ src_sv);
                memcpy(dest_c, &ptr, sizeof(void *));
            }
            break;
        }
    case INFIX_TYPE_STRUCT:
    case INFIX_TYPE_UNION:
        {
            if (!SvROK(src_sv) || SvTYPE(SvRV(src_sv)) != SVt_PVHV) {
                Perl_warn(aTHX_ "Attempted to marshal a non-hash reference to a struct/union; zeroing memory");
                memset(dest_c, 0, type_info->size);
                return;
            }
            HV * hash = (HV *)SvRV(src_sv);
            for (size_t i = 0; i < type_info->meta.aggregate_info.num_members; ++i) {
                const infix_struct_member * affix_member = &type_info->meta.aggregate_info.members[i];
                if (affix_member->name) {
                    SV ** value_sv_ptr = hv_fetch(hash, affix_member->name, strlen(affix_member->name), 0);
                    if (value_sv_ptr) {
                        void * member_dest = (char *)dest_c + affix_member->offset;
                        marshal_sv_to_c(aTHX_ member_dest, *value_sv_ptr, affix_member->type);
                    }
                }
            }
            break;
        }
    case INFIX_TYPE_ARRAY:
        {
            if (!SvROK(src_sv) || SvTYPE(SvRV(src_sv)) != SVt_PVAV) {
                Perl_warn(aTHX_ "Attempted to marshal a non-array reference to an array; zeroing memory");
                memset(dest_c, 0, type_info->size);
                return;
            }
            AV * av = (AV *)SvRV(src_sv);
            const infix_type * elem_type = type_info->meta.array_info.element_type;
            size_t num_elems = type_info->meta.array_info.num_elements;
            size_t av_len = av_count(av);

            for (size_t i = 0; i < num_elems; ++i) {
                void * elem_dest = (char *)dest_c + (i * elem_type->size);
                if (i < av_len) {
                    SV ** elem_sv_ptr = av_fetch(av, i, 0);
                    if (elem_sv_ptr) {
                        marshal_sv_to_c(aTHX_ elem_dest, *elem_sv_ptr, elem_type);
                    }
                    else {
                        memset(elem_dest, 0, elem_type->size);
                    }
                }
                else {
                    memset(elem_dest, 0, elem_type->size);
                }
            }
            break;
        }
    case INFIX_TYPE_REVERSE_TRAMPOLINE:
        {
            // This case handles a Perl Code Ref (CV*) being passed to a C function
            // that expects a function pointer.
            if (SvROK(src_sv) && SvTYPE(SvRV(src_sv)) == SVt_PVCV) {
                // Create a context to bridge from C back to this specific Perl sub.
                Affix_Callback_Data * ctx;
                Newxz(ctx, 1, Affix_Callback_Data);
                storeTHX(ctx->perl);
                ctx->perl_sub = newSVsv(src_sv); // Increment refcount to keep the sub alive

                const infix_type * func_sig = type_info;
                infix_type * ret_type = func_sig->meta.func_ptr_info.return_type;
                size_t num_args = func_sig->meta.func_ptr_info.num_args;
                size_t num_fixed_args = func_sig->meta.func_ptr_info.num_fixed_args;

                // Create a temporary array of type pointers for the infix API.
                infix_type ** arg_types = safemalloc(sizeof(infix_type*) * num_args);
                for(size_t i = 0; i < num_args; ++i) {
                    arg_types[i] = func_sig->meta.func_ptr_info.args[i].type;
                }

                // JIT-compile the reverse trampoline.
                infix_reverse_t * rt = NULL;
                infix_status status =
                    infix_reverse_create_manual(&rt, ret_type, arg_types, num_args, num_fixed_args,
                                                (void *)_Affix_callback_handler, ctx);

                safefree(arg_types);

                if (status != INFIX_SUCCESS) {
                    //~ SvREFCNT_dec(ctx->perl_sub);
                    safefree(ctx);
                    croak("Failed to generate implicit callback trampoline");
                }

                // LEAK PREVENTION: Register the new callback with the parent context for cleanup.
                if (current_call_context) {
                    av_push(current_call_context->owned_callbacks, newSViv(PTR2IV(rt)));
                } else {
                    warn("Created an on-the-fly callback without a parent context; it will be leaked.");
                }

                // Get the executable address of the new trampoline.
                void * func_ptr = infix_reverse_get_code(rt);
                // Write the function pointer to the C argument buffer.
                memcpy(dest_c, &func_ptr, sizeof(void *));
                return;
            } else {
                warn("Expected a code reference for a function pointer argument, got something else.");
                void * null_ptr = NULL;
                memcpy(dest_c, &null_ptr, sizeof(void*));
            }
            break;
        }
    default:
        Perl_warn(aTHX_ "Marshalling for type category %d is not yet implemented.", type_info->category);
        break;
    }
}

/**
 * @brief Fetches (reads and converts) C data into a new Perl SV.
 * @param src_c A pointer to the C memory to read from.
 * @param type_info The infix infix_type that describes the C memory layout.
 * @return A new, mortal Perl SV representing the data.
 */
SV * ptr2sv(pTHX_ void * src_c, const infix_type * type_info) {
    if (!src_c || !type_info)
        return sv_newmortal();

    switch (type_info->category) {
    case INFIX_TYPE_PRIMITIVE:
        {
            switch (type_info->meta.primitive_id) {
            case INFIX_PRIMITIVE_BOOL:        { bool val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVbool(val)); }
            case INFIX_PRIMITIVE_SINT8:       { int8_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSViv(val)); }
            case INFIX_PRIMITIVE_UINT8:       { uint8_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVuv(val)); }
            case INFIX_PRIMITIVE_SINT16:      { int16_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSViv(val)); }
            case INFIX_PRIMITIVE_UINT16:      { uint16_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVuv(val)); }
            case INFIX_PRIMITIVE_SINT32:      { int32_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSViv(val)); }
            case INFIX_PRIMITIVE_UINT32:      { uint32_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVuv(val)); }
            case INFIX_PRIMITIVE_SINT64:      { int64_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSViv(val)); }
            case INFIX_PRIMITIVE_UINT64:      { uint64_t val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVuv(val)); }
            case INFIX_PRIMITIVE_FLOAT:       { float val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVnv(val)); }
            case INFIX_PRIMITIVE_DOUBLE:      { double val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVnv(val)); }
            case INFIX_PRIMITIVE_LONG_DOUBLE: { long double val; memcpy(&val, src_c, sizeof(val)); return sv_2mortal(newSVnv(val)); }
#if !defined(INFIX_COMPILER_MSVC)
            case INFIX_PRIMITIVE_SINT128:
            case INFIX_PRIMITIVE_UINT128:
                {
                    __int128 val;
                    memcpy(&val, src_c, sizeof(val));
                    return sv_2mortal(newSViv((IV)val)); // Truncation
                }
#endif
            }
            break;
        }
    case INFIX_TYPE_POINTER:
    case INFIX_TYPE_REVERSE_TRAMPOLINE:
        {
            void * returned_c_ptr;
            memcpy(&returned_c_ptr, src_c, sizeof(void *));
            if (returned_c_ptr == NULL)
                return sv_newmortal();

            Affix_Pointer * ptr_struct;
            Newxz(ptr_struct, 1, Affix_Pointer);
            ptr_struct->address = returned_c_ptr;
            ptr_struct->managed = 0;
            ptr_struct->position = 0;
            ptr_struct->count = 1;
            ptr_struct->type = (type_info->category == INFIX_TYPE_POINTER) ?
                                type_info->meta.pointer_info.pointee_type :
                                type_info;
            ptr_struct->type_arena = NULL;

            SV * object_sv = newSV(0);
            sv_setiv(object_sv, PTR2IV(ptr_struct));
            SV * ref = newRV_noinc(object_sv);
            sv_bless(ref, gv_stashpv("Affix::Pointer::Unmanaged", GV_ADD));

            return sv_2mortal(ref);
        }
    case INFIX_TYPE_STRUCT:
    case INFIX_TYPE_UNION:
        {
            HV * hash = newHV();
            for (size_t i = 0; i < type_info->meta.aggregate_info.num_members; ++i) {
                const infix_struct_member * affix_member = &type_info->meta.aggregate_info.members[i];
                if (affix_member->name) {
                    void * member_src = (char *)src_c + affix_member->offset;
                    SV * val_sv = ptr2sv(aTHX_ member_src, affix_member->type);
                    hv_store(hash, affix_member->name, strlen(affix_member->name), val_sv, 0);
                }
            }
            return sv_2mortal(newRV_noinc((SV *)hash));
        }
    case INFIX_TYPE_ARRAY:
        {
            AV * av = newAV();
            const infix_type * elem_type = type_info->meta.array_info.element_type;
            size_t num_elems = type_info->meta.array_info.num_elements;
            for (size_t i = 0; i < num_elems; ++i) {
                void * elem_src = (char *)src_c + (i * elem_type->size);
                SV * elem_sv = ptr2sv(aTHX_ elem_src, elem_type);
                av_push(av, elem_sv);
            }
            return sv_2mortal(newRV_noinc((SV *)av));
        }
    default:
        Perl_warn(aTHX_ "Unmarshalling for type category %d is not yet implemented.", type_info->category);
        return sv_newmortal();
    }
    return sv_newmortal();
}
