
/**
 * @file marshal.c
 * @brief Implements data marshalling between Perl SVs and C types.
 *
 * @details This file contains the centralized logic for converting data back
 * and forth between Perl's dynamic `SV` representation and the static,
 * raw memory layout of C.
 *
 * It uses the `infix_type` descriptors generated by the `infix` library as a
 * blueprint to perform these conversions correctly, handling everything from
 * simple primitives to complex, nested structs.
 */

#include "../Affix.h"
#include <string.h>  // For strlen and memcpy

// Forward declaration for recursive struct/array marshalling
void marshal_sv_to_c(pTHX_ void * dest_c, SV * src_sv, const infix_type * type_info);
SV * fetch_c_to_sv(pTHX_ void * src_c, const infix_type * type_info);

/**
 * @brief Marshals (converts and writes) a Perl SV to a C memory location.
 * @param dest_c A pointer to the C memory to write to.
 * @param src_sv The source Perl SV containing the data.
 * @param type_info The infix infix_type that describes the C memory layout.
 */
void marshal_sv_to_c(pTHX_ void * dest_c, SV * src_sv, const infix_type * type_info) {
    if (!dest_c || !type_info)
        return;

    if (!SvOK(src_sv)) {
        // Handle undef: zero out the C memory.
        memset(dest_c, 0, type_info->size);
        return;
    }
    warn("type_info->category: %d", type_info->category);
    sv_dump(src_sv);
    switch (type_info->category) {
    case INFIX_TYPE_PRIMITIVE:
        {
            warn("type_info->meta.primitive_id: %d", type_info->meta.primitive_id);

            switch (type_info->meta.primitive_id) {
            case INFIX_PRIMITIVE_BOOL:
                {
                    bool val = SvTRUE(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_SINT8:
                {
                    int8_t val = SvIV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_UINT8:
                {
                    uint8_t val = SvUV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_SINT16:
                {
                    int16_t val = SvIV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_UINT16:
                {
                    uint16_t val = SvUV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_SINT32:
                {
                    warn("to int!!!!!!!!!!!");
                    //~ if (dest_c == NULL)
                    Newxz(dest_c, 1, int32_t);
                    warn("a");
                    int32_t val = SvIV(src_sv);
                    warn("b:%d", val);
                    Copy(&val, dest_c, 1, int32_t);
                    //~ memcpy(dest_c, &val, sizeof(val));
                    DumpHex(dest_c, 16);
                    warn("returning...");
                    break;
                }
            case INFIX_PRIMITIVE_UINT32:
                {
                    uint32_t val = SvUV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_SINT64:
                {
                    int64_t val = SvIV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_UINT64:
                {
                    uint64_t val = SvUV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_FLOAT:
                {
                    float val = SvNV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_DOUBLE:
                {
                    double val = SvNV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
            case INFIX_PRIMITIVE_LONG_DOUBLE:
                {
                    long double val = SvNV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
#if !defined(INFIX_COMPILER_MSVC)
            case INFIX_PRIMITIVE_SINT128:
            case INFIX_PRIMITIVE_UINT128:
                {
                    __int128 val = SvIV(src_sv);
                    memcpy(dest_c, &val, sizeof(val));
                    break;
                }
#endif
            }
            break;
        }
    case INFIX_TYPE_POINTER:
        {

            // Check if the source is a code ref and the destination C type is a function pointer.
            // A function pointer's infix_type will have a category of INFIX_TYPE_POINTER, but we need
            // a way to know it's specifically for a function. We'll need to enhance infix's
            // infix_type struct to hold this info.
            // For now, we will rely on the signature parsing logic to give us a hint.
            // Let's assume for now that if we get a code ref, we should try to make a callback.

            if (SvROK(src_sv) && SvTYPE(SvRV(src_sv)) == SVt_PVCV) {
                // This is the magic: we received a sub where a pointer was expected.
                // We will now generate a reverse trampoline on the fly.

                // TODO: To make this robust, the `infix_type` for a function pointer
                // needs to contain the signature information. This requires a change
                // to the infix parser. For now, we cannot implement this fully without
                // that change. We will leave a placeholder.

                // Placeholder: store NULL. This will cause the test to fail with -1.
                void * func_ptr = NULL;
                memcpy(dest_c, &func_ptr, sizeof(void *));

                // The full implementation would look like this:
                /*
                const infix_type* func_ptr_info = type_info->meta.pointer_info.pointee_type;

                Affix_Callback_Data* ctx;
                Newxz(ctx, 1, Affix_Callback_Data);
                storeTHX(ctx->perl);
                ctx->perl_sub = newSVsv(src_sv);
                ctx->return_type = func_ptr_info->meta.func_ptr_info.return_type;
                ctx->num_args    = func_ptr_info->meta.func_ptr_info.num_args;

                if (ctx->num_args > 0) {
                    ctx->arg_types = (const infix_type**) safemalloc(ctx->num_args * sizeof(infix_type *));
                    for(size_t i = 0; i < ctx->num_args; i++) {
                        ctx->arg_types[i] = func_ptr_info->meta.func_ptr_info.args[i].type;
                    }
                } else {
                    ctx->arg_types = NULL;
                }


                infix_reverse_t* rt = NULL;
                infix_status status = infix_reverse_create_manual(&rt, ctx->return_type, (infix_type**)ctx->arg_types,
                ctx->num_args, ctx->num_args, (void*)_Affix_callback_handler, ctx);

                if (ctx->arg_types) safefree(ctx->arg_types);

                void* func_ptr = infix_reverse_get_code(rt);
                memcpy(dest_c, &func_ptr, sizeof(void*));
                // IMPORTANT: We have just created a trampoline that needs to be freed.
                // This implies a memory management strategy is needed for on-the-fly callbacks.
                */
                return;
            }

            void * ptr = NULL;
            // Check if the source is an Affix::Pointer object first.
            if (sv_isobject(src_sv) && sv_derived_from(src_sv, "Affix::Pointer")) {
                // It is. Get the internal C struct...
                Affix_Pointer * ptr_struct = INT2PTR(Affix_Pointer *, SvIV(SvRV(src_sv)));
                // ...and extract the raw address.
                if (ptr_struct)
                    ptr = ptr_struct->address;
            }
            else if (is_pin(aTHX_ src_sv)) {
                Affix_Pin * pin = get_pin(aTHX_ src_sv);
                if (pin)
                    ptr = pin->pointer;
            }
            else if (SvPOK(src_sv)) {
                ptr = (void *)SvPV_nolen(src_sv);
            }
            else if (SvIOK(src_sv)) {
                ptr = INT2PTR(void *, SvIV(src_sv));
            }
            memcpy(dest_c, &ptr, sizeof(void *));
            break;
        }
    case INFIX_TYPE_STRUCT:
    case INFIX_TYPE_UNION:
        {
            if (!SvROK(src_sv) || SvTYPE(SvRV(src_sv)) != SVt_PVHV) {
                Perl_warn(aTHX_ "Attempted to marshal a non-hash reference to a struct/union; zeroing memory");
                memset(dest_c, 0, type_info->size);
                return;
            }
            HV * hash = (HV *)SvRV(src_sv);
            for (size_t i = 0; i < type_info->meta.aggregate_info.num_members; ++i) {
                const infix_struct_member * affix_member = &type_info->meta.aggregate_info.members[i];

                // --- CORRECTED API CALL ---
                // Use hv_fetch, which takes a pointer and a length, not hv_fetchs.
                SV ** value_sv_ptr = hv_fetch(hash, affix_member->name, strlen(affix_member->name), 0);

                if (value_sv_ptr) {
                    void * member_dest = (char *)dest_c + affix_member->offset;
                    marshal_sv_to_c(aTHX_ member_dest, *value_sv_ptr, affix_member->type);
                }
            }
            break;
        }
    case INFIX_TYPE_ARRAY:
        {
            if (!SvROK(src_sv) || SvTYPE(SvRV(src_sv)) != SVt_PVAV) {
                Perl_warn(aTHX_ "Attempted to marshal a non-array reference to an array; zeroing memory");
                memset(dest_c, 0, type_info->size);
                return;
            }
            AV * av = (AV *)SvRV(src_sv);
            const infix_type * elem_type = type_info->meta.array_info.element_type;
            size_t num_elems = type_info->meta.array_info.num_elements;
            size_t av_len = av_len(av) + 1;

            for (size_t i = 0; i < num_elems; ++i) {
                void * elem_dest = (char *)dest_c + (i * elem_type->size);
                if (i < av_len) {
                    SV ** elem_sv_ptr = av_fetch(av, i, 0);
                    if (elem_sv_ptr) {
                        marshal_sv_to_c(aTHX_ elem_dest, *elem_sv_ptr, elem_type);
                    }
                    else {
                        memset(elem_dest, 0, elem_type->size);
                    }
                }
                else {
                    memset(elem_dest, 0, elem_type->size);
                }
            }
            break;
        }
    case INFIX_TYPE_REVERSE_TRAMPOLINE:
        {
            if (SvROK(src_sv) && SvTYPE(SvRV(src_sv)) == SVt_PVCV) {
                // We received a code ref where a function pointer is expected.
                // Generate a reverse trampoline on the fly.

                Affix_Callback_Data * ctx;
                Newxz(ctx, 1, Affix_Callback_Data);
                storeTHX(ctx->perl);
                ctx->perl_sub = newSVsv(src_sv);  // Increment refcount
                ctx->return_type = type_info->meta.func_ptr_info.return_type;
                ctx->num_args = type_info->meta.func_ptr_info.num_args;

                // Extract infix_type* from the infix_function_argument array
                if (ctx->num_args > 0) {
                    ctx->arg_types = (const infix_type **)safemalloc(ctx->num_args * sizeof(infix_type *));
                    for (size_t i = 0; i < ctx->num_args; i++) {
                        ctx->arg_types[i] = type_info->meta.func_ptr_info.args[i].type;
                    }
                }
                else {
                    ctx->arg_types = NULL;
                }

                infix_reverse_t * rt = NULL;

                infix_status status =
                    infix_reverse_create_manual(&rt,
                                                (infix_type *)ctx->return_type,
                                                (infix_type **)ctx->arg_types,
                                                ctx->num_args,
                                                ctx->num_args,  // Not supporting variadic implicit callbacks for now
                                                (void *)_Affix_callback_handler,
                                                ctx);

                if (ctx->arg_types)
                    safefree(ctx->arg_types);

                if (status != INFIX_SUCCESS) {
                    SvREFCNT_dec(ctx->perl_sub);
                    safefree(ctx);
                    croak("Failed to generate implicit callback trampoline");
                }

                void * func_ptr = infix_reverse_get_code(rt);
                memcpy(dest_c, &func_ptr, sizeof(void *));

                // TODO: A robust implementation needs a way to free these on-the-fly trampolines.
                // For now, they will leak, but this proves the concept.
                return;
            }
            warn("Expected a code reference");
        }
    default:
        break;
    }
}

/**
 * @brief Fetches (reads and converts) C data into a new Perl SV.
 * @param src_c A pointer to the C memory to read from.
 * @param type_info The infix infix_type that describes the C memory layout.
 * @return A new, mortal Perl SV representing the data.
 */
SV * fetch_c_to_sv(pTHX_ void * src_c, const infix_type * type_info) {
    if (!src_c || !type_info)
        return newSV(0);

    switch (type_info->category) {
    case INFIX_TYPE_PRIMITIVE:
        {
            switch (type_info->meta.primitive_id) {
            case INFIX_PRIMITIVE_BOOL:
                {
                    bool val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVbool(val));
                }
            case INFIX_PRIMITIVE_SINT8:
                {
                    int8_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSViv(val));
                }
            case INFIX_PRIMITIVE_UINT8:
                {
                    uint8_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVuv(val));
                }
            case INFIX_PRIMITIVE_SINT16:
                {
                    int16_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSViv(val));
                }
            case INFIX_PRIMITIVE_UINT16:
                {
                    uint16_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVuv(val));
                }
            case INFIX_PRIMITIVE_SINT32:
                {
                    //~ int32_t val;
                    //~ memcpy(&val, src_c, sizeof(val));
                    //~ warn("2sv: %d", **(int **)src_c);
                    //~ DumpHex(src_c, 16);
                    return (newSViv(**(int32_t **)src_c));
                }
            case INFIX_PRIMITIVE_UINT32:
                {
                    uint32_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVuv(val));
                }
            case INFIX_PRIMITIVE_SINT64:
                {
                    int64_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSViv(val));
                }
            case INFIX_PRIMITIVE_UINT64:
                {
                    uint64_t val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVuv(val));
                }
            case INFIX_PRIMITIVE_FLOAT:
                {
                    float val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVnv(val));
                }
            case INFIX_PRIMITIVE_DOUBLE:
                {
                    double val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVnv(val));
                }
            case INFIX_PRIMITIVE_LONG_DOUBLE:
                {
                    long double val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSVnv(val));
                }
#if !defined(INFIX_COMPILER_MSVC)
            case INFIX_PRIMITIVE_SINT128:
            case INFIX_PRIMITIVE_UINT128:
                {
                    __int128 val;
                    memcpy(&val, src_c, sizeof(val));
                    return (newSViv(val));
                }
#endif
            }
            break;
        }
    case INFIX_TYPE_POINTER:
        {
            void * returned_c_ptr;
            memcpy(&returned_c_ptr, src_c, sizeof(void *));
            if (returned_c_ptr == NULL)
                return newSV(0);

            Affix_Pointer * ptr_struct;
            Newxz(ptr_struct, 1, Affix_Pointer);
            ptr_struct->address = returned_c_ptr;
            ptr_struct->managed = 0;
            ptr_struct->position = 0;
            ptr_struct->count = 1;                                      // Assume it points to 1 thing
            ptr_struct->type = (infix_type *)infix_type_create_void();  // Placeholder type
            ptr_struct->type_arena = NULL;

            SV * object_sv = newSV(0);
            sv_setiv(object_sv, PTR2IV(ptr_struct));
            SV * ref = newRV_noinc(object_sv);
            sv_bless(ref, gv_stashpv("Affix::Pointer", GV_ADD));

            return ref;
        }
    case INFIX_TYPE_STRUCT:
    case INFIX_TYPE_UNION:
        {
            HV * hash = newHV();
            for (size_t i = 0; i < type_info->meta.aggregate_info.num_members; ++i) {
                const infix_struct_member * affix_member = &type_info->meta.aggregate_info.members[i];
                void * member_src = (char *)src_c + affix_member->offset;
                SV * val_sv = fetch_c_to_sv(aTHX_ member_src, affix_member->type);

                // --- CORRECTED API CALL ---
                // Use hv_store, which takes a pointer and a length, not hv_stores.
                // The final 0 tells Perl to compute the hash of the key for us.
                hv_store(hash, affix_member->name, strlen(affix_member->name), val_sv, 0);
            }
            return (newRV_noinc((SV *)hash));
        }
    case INFIX_TYPE_ARRAY:
        {
            AV * av = newAV();
            const infix_type * elem_type = type_info->meta.array_info.element_type;
            size_t num_elems = type_info->meta.array_info.num_elements;
            for (size_t i = 0; i < num_elems; ++i) {
                void * elem_src = (char *)src_c + (i * elem_type->size);
                SV * elem_sv = fetch_c_to_sv(aTHX_ elem_src, elem_type);
                av_push(av, elem_sv);
            }
            return (newRV_noinc((SV *)av));
        }
    default:
        return newSV(0);
    }
    return newSV(0);
}
